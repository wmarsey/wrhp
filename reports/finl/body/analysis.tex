\chapter{Analysis}

\section{Calculation}

The data we collect via the Wikipedia API goes through a series of
procedures in order to extract measurements of it.

%pair comparison / weighted distance
First we compare the difference between the child-parent pairs of
revisions. This process is fairly simple, and is described in
algorithm~\ref{pair-comp}. The only special condition we introduce
here is comparing the oldest revision with an empty string.

%%%%% Pair comparison algorithm
\begin{algorithm}
\caption{Pair comparison}\label{pair-comp}
  \begin{algorithmic}
    \Procedure{PairComparison}{$revids$}
    \For {$ i \gets 0, $length($revids$)}
    \If{pair distance not already in database}
    \State $str1 \gets $\LineIf{``"}{$i=0$}{database.gettext($revs[i-1]$)}
    \State $str2 \gets $database.gettext($revs[i]$)
    \State $dist \gets $PairDistance($str1, str2$)\Comment{See algorithm~\ref{dist-calc}}
    \State databaseinsert.pairdistanceinsert($dist$)  
    \EndIf
    \EndFor
  \EndProcedure
  \end{algorithmic}
\end{algorithm}

The interest, instead, is in exactly how we calculate this
distance. We discussed earlier that we would use native WikiMarkup
tags in order to identify different `species' of text. By doing so, we
could characterise a single revision in terms of the kinds of text
dealt in. By characterising an edit with a series of different edit
difference we also perhaps create the opportunity to consider some as
more valuable than others.

The algorithm that was settled upon left the levenshtein calculator
itself naive of text species -- instead we simply split the text up
and calculate levenstein distance separately. We traverse each string
from beginning to end, using simple regex expressions to identify and
extract different kinds of text, and calculating the levenshtein
distance for each separately. This process is detailed in
algorithm~\ref{dist-calc}. 

%%%%% Distance calculation procedure
\begin{algorithm}
  \caption{Revision pair distance calculation}\label{dist-calc}
  \begin{algorithmic}
    \State $regexes \gets $\{
    \Statex \tab`math1': `$<$math$>$((?!$<${\textbackslash}/math$>$).)*$<${\textbackslash}/math$>${\textbackslash}S',
    \Statex \tab`math2': `\{\{math((?!\}\}).)*\}\}',
    \Statex \tab`bquote': `$<$blockquote$>$((?!$<${\textbackslash}/blockquote$>$).)*$<${\textbackslash}/blockquote$>${\textbackslash}S'
    \Statex  \tab...
    \Statex\}\Comment{Regexes that recognise single Wikimarkup tags}
    \State $reggroups \gets $\{\label{dist-calc-groups}
    \Statex  \tab`maths':(regexes[`math1'], regexes[`math2']),
    \Statex  \tab...
    \Statex \}\Comment{Group of regexes by 'species'}
    \State $distances \gets \emptyset$
    \Function{PairDistance}{$str1,str2$}
    \State $strs \gets [str1, str2]$
    \ForAll {$key, reg \in reggroups$}
    \State $comparestr \gets [``", ``"]$
    \For {$i \gets 0,1$}
    \State $matches \gets reg.matches(strs[i])$
    \ForAll {$m \in matches$}
    \State $match, strs[i] \gets $extractsplit($m.start, m.end, strs[i]$)
    \State $comparestr[i] \gets comparestr[i] + match$
    \EndFor
    \EndFor
    \If {length($comparestr[0]$)$ > 0$ OR length($comparestr[1]$)$ > 0$}
    \State $distances[key] \gets LevDist(comparestr[0], comparestr[1])$ \Comment{See algorithm~\ref{lev-dist}}
    \Else
    \State $distances[key] \gets 0$
    \EndIf
    \EndFor
    \State $distances[$`$norm$'$] \gets LevDist(strs[0], strs[1])$
    \Comment{Process the remainder}
    \State return $distances$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

In practice, this algorithm was much quicker than trying to add an
awareness of text species to the levenshtein calculator itself. We
using regex statements, we can search and split the string relatively
quickly, and use this preprocessing to alleviate the levenshtein
distance calculator of the burden of being aware of the kinds of text
it is dealing with. With this awareness integrated, because
levenshtein distance considers one character at a time, these
operations of flagging and identifying areas of text were inevitably
multiplied many thousands of time in one operation. Instead we were
able to use a fairly simply algorithm for calculating levenshtein
distance, found in algorithm~\ref{lev-dist}.

We will discuss different levenshtein-related algorithms further on
this thesis, but for now we can say that the one we reference here is
fairly basic, but with an optimised space efficiency. We see that we
don't hold a whole matrix for the two strings, only the current and
previous row. We may also describe the PairDistance overall as a
divide-and-conquer algorithm. It improves the space complexity of the
algorithm a little, and allows us the employ parallel or threaded
processing in order to improve efficiency of computation.

\begin{algorithm}
  \caption{Levenshtein distance calculator}\label{lev-dist}
  \begin{algorithmic}
    \Function{LevDist}{$str1, str2$}
    \State $s1len \gets $length($str1$)
    \State $s2len \gets $length($str2$)
    \State $column \gets [0_{1}, 0_{2}, \ldots, 0_{s1len}]$
    \For{$x \gets 1,s2len$}
    \State $col[x] \gets x$
    \EndFor
    \For{$p \gets 1,s1len$}
    \State $column[0] \gets p$
    \State $r \gets p-1$
    \For{$q \gets 1,s2len$}
    \State $oldnum \gets column[q]$
    \State $column[q] \gets min(col[q]+1, col[q-1] + 1, r + str1[p-1] \neq str2[q-1])$
    \EndFor
    \EndFor
    \State return $col[s1len]$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Our most important algorithm, however, is the trajectory calculation
algorithm. With this algorithm we allow ourselves to automatically
identify some of the context of the revision history, using the same
tools with which we analyse pair distance.

We consider that, although Wikipedia articles have no endpoint as a
rule -- we refer to page~\ref{quote-page} -- we must take the most
recent page in our history sample as a kind of `goal'. We measure
every revision's levenshtein distance from the final version, giving
us an idea of how close to `finished' it is, at least in terms of this
history. We then, taking that levenshtein distance as $\Delta y$,
and the time difference between the two as $\Delta x$, we calculate
the following:

\[gfactor(\Delta x,\Delta y) = \left\{ 
\begin{array}{l l l}
  1 & \quad \text{if ${\Delta}x = 0$ and ${\Delta}y < 0$ }\\
  0 & \quad \text{if ${\Delta}x = 0$ and ${\Delta}y >= 0$ }\\
  \frac{arctan({\Delta}y/{\Delta}x)}{\pi}\text{if ${\Delta}x > 0$}
\end{array} \right.\]

This function maps every point on a given arc to a real number in the
range 0 to 1 as shown in 

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[x=1.25cm,y=1.25cm]

    \draw[thick,dashed] (4,0) -- (4,8);
    \draw[thick,dashed] (4,4) -- (8,4);
    \draw (4,4) circle (3cm);
    \node[fill,circle] at (4,4) (o) {};
    
    \node[fill=white,left=1.5cm of o] at (2,4) {\textit{undefined region}};
    
    \draw [thick, ->] (o) -- (7,4) node[sloped, midway, above]{$0.5$};
    \draw [thick, ->] (o) -- (6,2) node[sloped, midway, above]{$0.75$};
    \draw [thick, ->] (o) -- (6,6) node[sloped, midway, below]{$0.25$};
    \draw [thick, ->] (o) -- (4,1) node[midway, right]{$1$};
    \draw [thick, ->] (o) -- (4,7) node[midway, right]{$0$};
  \end{tikzpicture}
\end{figure}

%%%%% Trace trajectory algorithm
\begin{algorithm}
\caption{Page trajectory calculation}\label{traj-calc}
  \begin{algorithmic}
    \Procedure{TrajectoryCalculation}{$revids, domain$}
    \State $target \gets $database.gettext($revids[-1]$)\Comment{Last revision in list is most recent}
    \For {$i \gets length(revids), 0$}
    \If{trajectory distance not already in database}
    \State $str1 \gets $database.gettext($revids[i]$)
    \State $dist \gets $LevDist($str1, target$)\Comment{See algorithm~\ref{lev-dist}}
    \State $database.inserttrajectoryinsert(dist)$    
    \EndIf
    \EndFor
    \For{$i \gets 0, length(revids)$}
    \State $dist2 \gets $database.gettrajectory($revids[i],domain$)
    \State $dist1 \gets$
        \LineIf{database.gettrajectory($revid[i-1],domain$)}{$i \neq 0$}{$2
          \times disty$}
    \State $time2 \gets $database.gettimestamp($revid[i],domain$)
    \State $time1 \gets $
        \LineIf{database.gettimestamp($revid[i-1],domain$)}{$i \neq 0$}{$timex$} 
    \State ${\Delta}x \gets time2 - time1$
    \State ${\Delta}y \gets dist2 - dist1$
    \If{${\Delta}x \neq 0$}
    \State $gradient = \frac{arctan({\Delta}y/{\Delta}x)}{\pi}$ 
    \Else 
    \State $gradient = $\LineIf{1}{$y < 0$}{0}
    \EndIf
    \State database.insertgradient($revid[i],domain,gradient$)
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}



