\chapter{Fetching the Data}

%% % Define block styles
%% \tikzstyle{decision} = [rectangle, 
%%   fill, 
%%   fill=yellowi, 
%%   text width=5em, 
%%   text badly centered, 
%%   node distance=3cm,
%%   inner sep=0.5em,
%%   outer sep=0,
%%   inner sep=0pt, 
%%   font=\footnotesize,
%% rounded corners,
%% execute at begin node=\setlength{\baselineskip}{1em}]
%% \tikzstyle{block} = [rectangle, 
%%   fill, 
%%   fill=greeni, 
%%   inner sep=0.5em,
%%   outer sep=0,
%%   text width=6em, 
%% %  text width=5em,
%%   text centered,
%%   font=\footnotesize,
%%   execute at begin node=\setlength{\baselineskip}{1em}] 
%% %rounded corners, 
%% %minimum height=4em]
%% \tikzstyle{line} = [draw, -latex']
%% \tikzstyle{cloud} = [fill, 
%%   ellipse,
%%   fill=redi,
%%   inner sep=0.5em,
%%   outer sep=0,
%%   node distance=3cm,
%%   minimum height=2em,
%%   font=\footnotesize,
%%   execute at begin node=\setlength{\baselineskip}{1em}]
    
%% \begin{figure}
%%   \label{fig:datafetchflow}
%%   \caption{Flow chart showing the Wikidata fetch algorithm}
%%   \begin{tikzpicture}[node distance = 1cm]
%%     % Place nodes

%%     \matrix (m) [row sep=3em,
%%     column sep=3em]{

%%       &
      
%%       \node [block] (init) {Initialise arrays.};
      
%%       &
      
%%       \node [decision]%% , right of=init, node distance=2cm
%%       (dompick) {Do we have a domain?};
      
%%       &

%%       \\

%%       &

%%       \node [block]%% , below of=dompick
%%       (domrandom) {Pick a random domain};

%%       &

%%       \node [decision]%% , right of=domrandom, node distance=2cm ]
%%       (pagepick) {Do we have a pageid?};
      
%%       & 

%%       \\
      
%%       &

%%       &
      
%%       \node [block]%% , below of=pagepick
%%       (pagerandom) {Fetch random pageid
%%         from current domain};
      
%%       &
      
%%       \node [decision]%% , right of=pagerandom, node distance=2cm
%%       (dbcheck) {Does the current
%%         ID and domain exist in the database already?};

%%       \\

%%       & 

%%       \node [decision]%% , left of=corruptcheck, node distance=2c
%%       (corruptcheckb) {Is the parentid intact?};
      
%%       &

%%       \node [decision]%% , left of=dbcheck, node distance=2cm 
%%       (corruptcheck) {Is the fetched data corrupt?};
      
%%       &

%%       \node [block]%% , below of=dbcheck 
%%       (fetchrecent) {Fetch most recent revision ID};
      
%%       \\
      
%%       &
      
%%       \node [block]%% , right of=corruptcheckb, node distance=3cm
%%       (appendcorrupt) {append to corrupt pages array};
      
%%       &
      
%%       \node [block]%% , below of=corruptcheckb, node distance=3cm
%%       (appenddisc) {Append to caches pages array.};
      
%%       &
      
%%       \node [block]%% , below of=appenddisc
%%       (idfetch) {Update revid using
%%         parent ID from held data};
      
%%       \\
      
%%       \node [decision]%% , below of=parentcheck
%%       (enoughb) {Do we have over X
%%         revisions in the visited array?};

%%       &

%%       \node [decision]%% , below of=enough
%%       (parentcheck) {Is parent 0, or
%%         does exist in the visited array};
      

%%       &

%%       \node [block]%% , right of=enough, node distance=3cm
%%       (store) {Store all pages in the cached pages array.};


%%       &

%%       \node [decision]%% , below of=idfetch
%%       (enough) {Do we have 50 pages
%%         in the cached pages array?};

%%       \\
      
%%       \node [block]%% , below of=parentcheck
%%       (storeb) {Store all pages in
%%         the cached pages array.};
      
%%       &

%%       \node [decision]%% , below of=storeb
%%       (corruptdeal) {Do we have any
%%         pages in the corrupt array?};
      
%%       &
      
%%       \node [block]%% , right of=corruptdeal, node distance=3cm
%%       (corruptproc) {Change pointers in database in order to 'skip over'
%%         corrupt pages.};
      
%%       &
      
%%       \node [decision]%% , right of=parentcheck
%%       (discard) {Discard page};

%%       \\

%%       &
      
%%       &
      
%%       \node [decision]%% , below of=corruptdeal
%%       (continue) {Continue?};
      
%%       &
      
%%       \node [cloud]%% , below of=continue
%%       (end) {End.};

%%       \\
%%     };
%%     % Draw edges
%%     \path [line] (init) -- (dompick);

%%     \path [line] (dompick) -- node [near start] {yes} (pagepick);

%%     \path [line] (dompick) -- node [near start] {no} (domrandom);

%%     \path [line] (domrandom) -- (pagepick);

%%     \path [line] (pagepick) -- node [near start] {yes} (fetchrecent);

%%     \path [line] (pagepick) -- node [near start] {no} (pagerandom);

%%     \path [line] (pagerandom) -- (fetchrecent);

%%     \path [line] (fetchrecent) -- (dbcheck);

%%     \path [line] (dbcheck) -- node [near start] {yes} (idfetch);

%%     \path [line] (dbcheck) -- node [near start] {no} (corruptcheck);
    
%%     \path [line] (corruptcheck) -- node [near start] {yes} (corruptcheckb);

%%     \path [line] (corruptcheck) -- node [near start] {no} (appenddisc);

%%     \path [line] (appenddisc) -- (idfetch);

%%     \path [line] (corruptcheckb) -- node [near start] {yes} (continue);

%%     \path [line] (corruptcheckb) -- node [near start] {no} (appendcorrupt);

%%     \path [line] (appendcorrupt) -- (idfetch);

%%     \path [line] (idfetch) -- (enough);

%%     \path [line] (enough) -- node [near start] {yes} (store);

%%     \path [line] (enough) -- node [near start] {no} (parentcheck);

%%     \path [line] (store) -- (parentcheck);

%%     \path [line] (parentcheck) -- node [near start] {yes} (enoughb);

%%     \path [line] (parentcheck) -- node [near start] {no} (dbcheck);

%%     \path [line] (enoughb) -- node [near start] {yes} (storeb);

%%     \path [line] (enoughb) -- node [near start] {no} (discard);

%%     \path [line] (discard) -- (continue);

%%     \path [line] (storeb) -- (corruptdeal);

%%     \path [line] (corruptdeal) -- node [near start] {yes} (corruptproc);

%%     \path [line] (corruptdeal) -- node [near start] {no} (continue);

%%     \path [line] (corruptproc) -- (continue);

%%     \path [line] (continue) -- node [near start] {yes} (init);

%%     \path [line] (continue) -- node [near start] {no} (end);

%%   \end{tikzpicture}
%% \end{figure}

%%%% Data fetching algorithm
\begin{algorithmic}
  $corrupt \gets []$\\
  $visitedpages \gets []$\\
  $revid \gets 0$\\
  $parentid \gets -1$
  \While{parentid != 0 and revid not in visitedpages} 
      revid = parentid
      \If{revid \in database}
          \State $parentid \gets database.getparentid(revid)$
      \Else
          \State $pagedata \gets wiki.getpage(revid)$
      \EndIf
      \If{pagedata is corrupt}
          \State $corruptpages \gets corruptpages (revid, parentid, domain)$
      \Else
          \State $database \gets page data$
      \EndIf
          \State $visitedpages \gets visitedpages + (revid, domain)$
  \EndWhile
  \For {$(revision, parent, domain) \in corrupt$}
      \State $database.changepointers(revision, parent, domain)$\\
      \Comment{this changed the parentids of entries in order to 'circumnavigate' corrupt entries}
  \EndFor
\end{algorithmic}

%%%%% Pair comparison algorithm
\begin{algorithmic}
  \State $revs \gets database.fetchIDsofpage()$\\
  \For {$ i = 0 to length(revs)$}
  \If{$revs[i].dist not in database$}
  \State $str1 \gets ($``"$ if i == 0 else database.gettext(revs[i-1])$
  \State $str2 = database.gettext(str1, str2)$
  \State $dist \gets DistanceCalculate(str1, str2)$
  \State $databaseinsert.pairdistanceinsert(dist)$  
\EndFor
\end{algorithmic}

%%%%% Trace trajectory algorithm
\begin{algorithmic}
  \caption{Page trajectory calculation}\label{dist-calc}
  \State $revs \gets database.fetchIDsofpage()$\\
  \State $target \gets database.gettext(revs[-1])$ \Comment{Last revision in list is most recent}
  \For {$ i \gets length(revs) to 0$}
  \If{$database.gettrajectory(revs[i]) is Null$}
  \State $str1 \gets database.gettext(revs[i])$
  \State $dist \gets DistanceCalculate(str1, target)$
  \State $databaseinsert.trajectoryinsert(dist)$
\EndFor
\end{algorithmic}

%%%%% Distance calculation procedure
\begin{algorithm}
  \caption{Revision pair distance calculation}\label{dist-calc}
  \begin{algorithmic}
    \State $regexes \gets $\{
    \Statex  'math1': '<math>((?!<\/math>).)*<\/math>\S',
    \Statex  'math2': '\{\{math((?!\}\}).)*\}\}',
    \Statex 'bquote': '<blockquote>((?!<\/blockquote>).)*<\/blockquote>\S'
    \Statex  ...
    \Statex\}\Comment{Regexes that recognise single Wikimarkup tags}
    \State $reggroups \gets $\{
    \Statex  'maths':(regexes['math1'], regexes['math2']),
    \Statex  ...
    \Statex \}\Comment{Group of regexes by 'species'}
    \State $distances \gets {}$
    \Function{PairDistance}{$str1,str2$}
    \State $strs = [str1, str2]$
    \ForAll {$key, reg \in reggroups$}
    \State $distances[key] \gets 0$
    \State $comparestr \gets [``", ``"]$
    \For {$i = 0 to 1$}
    \State $matches \gets reg.matches(strs[i])$
    \ForAll {$m \in matches$}
    \State $match, strs[i] \gets extractsplit(m.start, m.end, strs[i])$
    \State $comparestr[i] \gets comparestr[i] + match$
    \EndFor
    \EndFor
    \If {len(comparestr[0]) or len(comparestr[1])}
    \State $levenshtein(comparestr[0], comparestr[1])$
    \EndIf
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}
