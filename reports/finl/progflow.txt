database = Database() //connection to database
wiki = Wikipedia() //connection to Wikipedia API
pageid = Null //initially null
weights = getweights() //sets of weights specified by user

//FETCH DATA
- visitedpages = [] //empty list
- corruptpages = []
-
- if pageid == Null:
- - if random:
- - - pageid = wiki.getrandom()
- - else:
- - - pageid = wiki.getpageid(specifiedpagetitle)
-
- parentid = revid = wiki.getlatestrevision(pageid)
-
- while parentid != 0 and revid not in visitedpages:
- - revid = parentid
- - if revid is in database:
- - - parentid = database.getparentid(revid)
- - else:
- - - pagedata = wiki.getpage(revid)
- - - if pagedata is corrupt:
- - - - corruptpages.insert({revid, parentid})
- - - else:
- - - - database.insert(pagedata)
- - visitedpages.insert(revid)
-
- for {crev, cparent} in currupt:
- - database.changepointers(crev, cparent)
- - //this changed the parentids of entries in order
- - //to 'circumnavigate' corrupt entries

//now we have our set of revision
- revs = database.getrevisions(pageid) 

//COMPARE PAIRS
- //revs is list of revids, ordered by time
-
- for i = 0 to length(revs):
- - if not database.getdist(revs[i]):
- - - str1 = ("" if i == 0 else database.gettext(revs[i-1]))
- - - str2 = database.gettext(revs[i])
- - - dist = lev.calculate(str1,str2)
- - -  //dist is a dictionary - integers indexed by variable
- - - database.insert(dist)

//TRACE TRAJECTORY
- target = database.gettext(revs[-1]) 
- //last in list is most recent rev
- 
- for i == length(revs) to 0:
- - if not database.gettrajectory(revs[i])
- - - dist = lev.calculate(database.gettext(revs[i],target))
- - - database.insert(dist)

//MATCH DIST DATA TO USER
- for i = 0 to length(revs):
- - dists = database.getdist(revs[i])
- - userid = database.getuser(revs[i])
- -
- - //using trajectory
- - time2, height2 = database.gettrajectory(revs[i])
- - if i == 0:
- - - time1 = time2
- - - height1 = 0
- - else:
- - - time1, height1 = database.gettrajectory(revs[i-1])
- - trajweight = atanfunc(time1, height1, time2, height2)
- - 
- - database.updateuser(userid, pageid, dists, trajweight) 
- - //increases numbers as approprate

//END RESULT
//unique to (pageid, userid) tuple, series of awards indexed by 
//type of text, then a trajectory number that can also be weighted

----------
//Modified Levenshtein distance
struct Wint{
       int w;
       int[] tags;
       int norm;
}
TAGOPENERS = {
     {'<',...,}, //openers
     {'>',...,}  //closers
}
TAGS = {
     {"<opentag>","</closingtag">},
     {"{{open","}}"},
     ...,
}

tagger(string, upflag, tagmutex):
     vindex = (int) tagmutex
     if not tagmutex:
          for i to len(TAGS)
	      if(startswith(sit, TAGS[i][vindex]):
	           upflag = i
		   return 1;
     else:
          if(startswith(str, TAGS[upflag][vindex]:
	        return strlen(TAGS[upflag][vindex]
     return 0

flagset(release, tagmutex, upflag, str, index):
     if tagmutex and release > 0:
     	  --release
     elif release == 0:
     	  tagmutex = False
	  --release
     elif indic(str[index], tagmutex):
          taglength = tagger(strstr+index, upflag, tagmutex)
	  if tagq:
	       if tagmutex: release = taglength
	       else tagmutex = true
	       

dist(str1, str2)
     yupflag = xupflag = c = pick = 0
     yrelease = xrelease = -1
     xtagmutex = ytagmutex = false
     
     Wint lastnum, oldnum, addw, delw, keepswap
     Wint column[len(s1) + 1]

     for j = 1 to len(str1)
     	 column[j].norm = column[j].w = j

     for i = 1 to len(str2)
         flagset(yrelease, ytagmutex, yupflag, s2, j-1)
	 
	 column[0].norm = column[0].w = i
	 
	 lastnum.w = i-1
	 
	 for j = 1 to len(str1)
	     oldnum = column[j]
	     
	     flagset(xrelease, xtagmutex, xupflag, s1, i-1)
	     
	     c = (s1[j-1] == s2[i=1] ? 0:1)
	     addw = column[j] + 1
	     delw = column[j-1] + 1
	     keepswapw = lastnum + c
	     column[j] = min(addw, delw, keepswapw)
	     
	     pick = minfo(addw, delw, keepswapw)	     

	     column[j].flagsum(column[j], 
	     		       c, 
			       pick, 
			       ytagmutex, 
			       xtagmutex,	
			       yupflag, 
			       xupflag)
			       
	     lastnum = oldnum;

     return column[len(s1)]
